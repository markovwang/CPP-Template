## 8.4 **SFIANE**法则(替换失败而非错误)

C++中重载函数以考虑不同的实参类型是一件很常见的事情. 当编译器看见调用了重载的函数, 其将独立的考虑不同的重载候选, 评估调用时的实参并选择最匹配的候选.

在重载候选中含有函数模板的这种情况下, 编译器首先要做的就是决定这个候选者应该使用什么样的模板实参. 然后将实参替换到参数列表和返回类型中, 然后评估有多匹配. 然而, 替换过程可能会出问题, 其可能产生毫无意义的结构. 相比将这个无意义的替换进行报错, 语言规则会选择将这个候选直接忽略掉.

我们将其称之为*SFIANE*, 读作*sfee-nay*, 其意味着"替换失败并非错误".

注意, 这个替换和按需替换应区分开. 这个替换过程甚至会在潜在的实例化尚未进行时就发生了. 这个替换就直接发生在函数的声明阶段(不在函数结构体中).

考虑下面的例子:

```cpp
// 裸数组中的元素数
template <typename T, unsigned N>
std::size_t len (T(&) [N]) {
    return N;
}

// 有 size_type的话
template <typename T>
typename T::size_type len (T const& t) {
    return t.size();
}
```

 此处, 我们定义了两个函数模板, 都需要一个模板实参.

1. 第一个函数模板声明参数形为`T(&)[N]`, 就意味着参数应为类型T, 长度为N的数组.
2. 第二个函数模板简化的声明为T, 其对形参没有任何约束, 但是声明了返回类型为`T::size_type`, 其要求传入的实参类型必须有相应的成员`size_type`.

当传入裸数组或者字符串字面量的时候, 只有第一个函数模板可以成功匹配:

```cpp
int a[10];
std::cout<<len(a);	// 只有第一个能够匹配
std::cout<<len("wocao");// 只有第一个才能匹配.
```

根据其签名, 第二个函数模板也可以进行模板的替换, 但是替换后可能导致返回类型的错误. 第二个模板因此也就被忽略了.

当传入`std::vector<>`时, 只有第二个模板能够匹配:

```cpp
std::vector<int> v;
std::cout<<len(v);		// 只有第二个才行.
```

当传入裸数组的时候, 两个都不能匹配, 结果就是编译器会说没有匹配的函数, (而非什么函数错误!):

```cpp
int* p;
std::cout<<len(p);		// 无法找到匹配的函数
```

注意, 这和传入一个具有`size_type`成员但是没有`size()`成员的类型是不一样的, 举个例子:`std::allocator<>`.

```cpp
std::allocator<int> x;
std::cout<<len(x);		//没有size()成员
```

当传入这样的类型的对象时, 编译期发现第二个函数模板能更好的匹配. 于是这和没有找到匹配的函数是不一样的, 现在的错误是, 不能调用`std::allocator<>`的`size()`成员, 这次, 第二个模板并没有被忽略.

如果忽略掉那些在替换之后返回值类型为无效的备选项, 那么编译器会选择另外一个参数类型匹配相差的备选项. 比如:

 ```cpp
 // number of elements in a raw array:
 template<typename T, unsigned N>
 std::size_t len (T(&)[N])
 {
 	return N;
 }
 // number of elements for a type having size_type:
 template<typename T>
 typename T::size_type len (T const& t)
 {
 	return t.size();
 }
 // fallback for all other types:
 std::size_t len (…)
 {
 	return 0;
 }
 ```

