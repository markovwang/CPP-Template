## 8.4 **SFIANE**法则(替换失败而非错误)

C++中重载函数以考虑不同的实参类型是一件很常见的事情. 当编译器看见调用了重载的函数, 其将独立的考虑不同的重载候选, 评估调用时的实参并选择最匹配的候选.

在重载候选中含有函数模板的这种情况下, 编译器首先要做的就是决定这个候选者应该使用什么样的模板实参. 然后将实参替换到参数列表和返回类型中, 然后评估有多匹配. 然而, 替换过程可能会出问题, 其可能产生毫无意义的结构. 相比将这个无意义的替换进行报错, 语言规则会选择将这个候选直接忽略掉.

我们将其称之为*SFIANE*, 读作*sfee-nay*, 其意味着"替换失败并非错误".

注意, 这个替换和按需替换应区分开. 这个替换过程甚至会在潜在的实例化尚未进行时就发生了. 这个替换就直接发生在函数的声明阶段(不在函数结构体中).

考虑下面的例子:

```cpp
// 裸数组中的元素数
template <typename T, unsigned N>
std::size_t len (T(&) [N]) {
    return N;
}

// 有 size_type的话
template <typename T>
typename T::size_type len (T const& t) {
    return t.size();
}
```

 此处, 我们定义了两个函数模板, 都需要一个模板实参.

1. 第一个函数模板声明参数形为`T(&)[N]`, 就意味着参数应为类型T, 长度为N的数组.
2. 第二个函数模板简化的声明为T, 其对形参没有任何约束, 但是声明了返回类型为`T::size_type`, 其要求传入的实参类型必须有相应的成员`size_type`.

当传入裸数组或者字符串字面量的时候, 只有第一个函数模板可以成功匹配:

```cpp
int a[10];
std::cout<<len(a);	// 只有第一个能够匹配
std::cout<<len("wocao");// 只有第一个才能匹配.
```

根据其签名, 第二个函数模板也可以进行模板的替换, 但是替换后可能导致返回类型的错误. 第二个模板因此也就被忽略了.

当传入`std::vector<>`时, 只有第二个模板能够匹配:

```cpp
std::vector<int> v;
std::cout<<len(v);		// 只有第二个才行.
```

当传入裸数组的时候, 两个都不能匹配, 结果就是编译器会说没有匹配的函数, (而非什么函数错误!):

```cpp
int* p;
std::cout<<len(p);		// 无法找到匹配的函数
```

注意, 这和传入一个具有`size_type`成员但是没有`size()`成员的类型是不一样的, 举个例子:`std::allocator<>`.

```cpp
std::allocator<int> x;
std::cout<<len(x);		//没有size()成员
```

当传入这样的类型的对象时, 编译期发现第二个函数模板能更好的匹配. 于是这和没有找到匹配的函数是不一样的, 现在的错误是, 不能调用`std::allocator<>`的`size()`成员, 这次, 第二个模板并没有被忽略.

如果忽略掉那些在替换之后返回值类型为无效的备选项, 那么编译器会选择另外一个参数类型匹配相差的备选项. 比如:

 ```cpp
 // number of elements in a raw array:
 template<typename T, unsigned N>
 std::size_t len (T(&)[N])
 {
 	return N;
 }
 // number of elements for a type having size_type:
 template<typename T>
 typename T::size_type len (T const& t)
 {
 	return t.size();
 }
 // fallback for all other types:
 std::size_t len (…)
 {
 	return 0;
 }
 ```

此处, 我们仍然提供了一个无论如何都可以匹配的`len()`版本, 但它总是匹配的最后选择. 

于是乎, 对于裸数组或者向量, 我们有两套匹配方案, 其中精确匹配总是更好的选择. 对于指针, 只有最烂的匹配可以匹配到, 所以编译器也不会报错. 但是对于内存分配器, 第二个和第三个是可以匹配的, 其中第二个更优. 于是乎, 当不能提供`size()`成员的时候就出现问题了.

```c++
int a[10];
std::cout<<len(a);		// array版的len()是最佳匹配.
std::cout<<len("tmp");	// array版的len()是最佳匹配.

std::vector<int> v;
std::cout<<len(v);		// 有size_type的len是最佳匹配.

int* p;
std::cout<<len(p);		// 只有最差的len重载才能匹配

std::allocator<int> x;
std::cout<<len(x);		// 第二个len可以匹配但是不能调用size()成员函数
```



#### SFINAE 和 重载解析

长久以来, SFIANE原则对于模板设计者已经成为一个重要且亲切的动词. 我们会说: '*we SFINAE out a function*'.这就意味着我们使用了SFIANE机制以保证模板会忽略某些限制. 只要我们在标准库中读到这样的话:"除非... 其不应该参加重载解析."这意味着SFIANE用以在某些情况下忽略某些函数模板.

举个例子, `std::thread`声明了这样一个构造函数.

```cpp
namespace std {
    class thread {
	public:
        // ...
        template<typename F, typename.. Args>
        explicit thread(F&& f, Args&&... args);
        // ...
    };
}
```

下面有这样一条注释:

> 注释: 如果`decay_t<F>`的类型为`std::thread`的情况下不参与重载决议.

这意味着, 如果将`std::thread`作为第一个且是唯一一个的实参的时候, 此模板构造函数将被忽略. 
