## 7.5 处理返回值

对于返回值, 你也可以决定是返回值还是返回引用. 然而, 返回引用可能是问题的一大源头, 因为你引用了无法控制的东西. 在日常编程实践中, 有一些返回引用的例子:

- 返回容器的元素或者字符串.
- 保证对类成员的访问.
- 返回链式调用的对象.

此外, 保证对成员的读访问,可以返回常引用. 

注意, 这些操作如果不合适的使用的话, 会导致问题, 举个例子:

```cpp
std::string* s = new std::string("whatever");
auto& c = (*s)[0];
delete s;
std::cout<<c;	//tuntime error
```

此处, 我们获得了一个字符串的一个元素的引用, 但是到我们使用这个引用的时候, 被引用的数组就不存在了, 于是出现了未定义的行为. 这个例子某种程度上来说属于认为的, 但是有时候事情不会那么明显, 举个例子:

```cpp
auto s = std::make_shared<std::string>("whatever");
auto& c = (*s)[0];
s.reset();
std::cout << c; //run-time ERROR
```

我们因此应该保证函数模板通过值返回结果. 然而, 就像在本章中讨论一样, 使用模板参数`T`并不保证这个这个不是引用, 因为`T`有时可能被隐式的推导为引用:

```cpp
template <typename T>
T retR(T&& p) {	// P是通用引用
    return T{...};		// 当使用左值调用的时候返回了引用
}
```

就算被推导为了通过值调用, 当显式的指定为引用时也会出问题:

```cpp
template <typename T>
T retV(T p) {		// T可能变为引用
    return T{...};		// 当T是引用的时候返回引用
}

int x;
retV<int&>(x);			// T成了 int&
```

为了安全, 我们有两个解决方案:

- 使用类型萃取`std::remove_reference<>`以将其转化为非引用
- 让编译器来决定返回值吧! 使用`auto`关键字即可. 因为`auto`也会退化.



