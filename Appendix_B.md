# 附录B: 值类别



表达式是C++的基石, 其提供了表达计算能力的主要机制. 每个表达式都有其类型, 用以描述某个表达式计算结果的类型, 比如表达式`7`的类型就是`int`, `5 + 2`的类型也是, 如果`x`的类型是`int`, 那么它的类型也是`int`, 每个表达式也有其`值类别`, 其描述了每个值是怎么构建的, 并影响这个表达式的行为.



## B.1 传统的左值与右值

以历史的观点来看, 只有两种值类别, 左值与右值. 左值是可以引用计算机内存或者寄存器的, 就比如表达式`x`, *x*就是变量的名字. 这个变量是可变的, 也可以更新存在其中的值, 举个例子, 如果`x`是一个`int`类型的变量, 下面的赋值语句将`x`的值替换为`7`:

```cpp
x = 7;
```

左值这一术语就来自在表达式在赋值中所扮演的角色:左, 即"左侧的". 因为(从历史角度讲)只有左值可以出现在赋值语句的左侧. 相反的, 右值只能出现在赋值表达式的右侧(即右手侧).

然而, C语言是在1989年标准化的, 大人, 时代变了, `int const`仍是在内存中的值, 不过不能出现在表达式的左侧:

```cpp
int const x;
x = 7;			// 炸了
```

C++ 在这方面走得更远,  类右值可以出现在赋值的左侧, 这种赋值实际上是对类的适当赋值操作符的函数调用, 而非对标量类型的简单赋值, 因为他们遵从单独的成员函数调用规则.

由于这些改变, 左值这个术语闲杂某些情况下代表着可局部化的值, 引用一个变量的表达式并非左值的全部形式. 另一种是包含指针解引用运算的.(`*p`这样的), 其指向了指针引用的地址存储的值, 还有指向类对象的成员的表达式(`p->data`这样的). 甚至还有使用`&`声明的, 返回传统左值引用类型的调用.举个例子:

```cpp
std::vector<int> v;
v.front();				// 返回左值, 因为返回类型是左值引用.
```

惊不惊喜, 意不意外, 字符串字面量也是(不可忽视的)左值. 

