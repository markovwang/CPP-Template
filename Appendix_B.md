# 附录B: 值类别



表达式是C++的基石, 其提供了表达计算能力的主要机制. 每个表达式都有其类型, 用以描述某个表达式计算结果的类型, 比如表达式`7`的类型就是`int`, `5 + 2`的类型也是, 如果`x`的类型是`int`, 那么它的类型也是`int`, 每个表达式也有其`值类别`, 其描述了每个值是怎么构建的, 并影响这个表达式的行为.



## B.1 传统的左值与右值

以历史的观点来看, 只有两种值类别, 左值与右值. 左值是可以引用计算机内存或者寄存器的, 就比如表达式`x`, *x*就是变量的名字. 这个变量是可变的, 也可以更新存在其中的值, 举个例子, 如果`x`是一个`int`类型的变量, 下面的赋值语句将`x`的值替换为`7`:

```cpp
x = 7;
```

左值这一术语就来自在表达式在赋值中所扮演的角色:左, 即"左侧的". 因为(从历史角度讲)只有左值可以出现在赋值语句的左侧. 相反的, 右值只能出现在赋值表达式的右侧(即右手侧).

然而, C语言是在1989年标准化的, 大人, 时代变了, `int const`仍是在内存中的值, 不过不能出现在表达式的左侧:

```cpp
int const x;
x = 7;			// 炸了
```

C++ 在这方面走得更远,  类右值可以出现在赋值的左侧, 这种赋值实际上是对类的适当赋值操作符的函数调用, 而非对标量类型的简单赋值, 因为他们遵从单独的成员函数调用规则.

由于这些改变, 左值这个术语闲杂某些情况下代表着可局部化的值, 引用一个变量的表达式并非左值的全部形式. 另一种是包含指针解引用运算的.(`*p`这样的), 其指向了指针引用的地址存储的值, 还有指向类对象的成员的表达式(`p->data`这样的). 甚至还有使用`&`声明的, 返回传统左值引用类型的调用.举个例子:

```cpp
std::vector<int> v;
v.front();				// 返回左值, 因为返回类型是左值引用.
```

惊不惊喜, 意不意外, 字符串字面量也是(不可忽视的)左值. 

右值是纯数学值, 比如`7`或者字符`a`, 他们没必要有什么相关的存储, 他们为了计算来到世上, 但在被使用过后无法再被引用. 特别的, 除了字符串字面量的任何字面值,都是右值, 大部分内建算术运算的结果, 比如`x+5`之类, 也返回右值. 即,所有临时值都是右值.



### B.1.1 左值到右值的转换

由于其短暂的生命周期, 右值有必要被限制到赋值语句的右侧, 类似`7=8`这样的表达式就毫无意义, 因为数学上的`7`并不允许被重新定义, 左值, 就没有这样的限制. 我们当然可以计算`x=y`这样的表达式, 就算他俩都是左值.

赋值表达式`x=y`能够计算的原因是其右侧的表达式`y`, 经过了隐式转换, 即*左值向右值的转换*. 就像其名字所暗示, 左值-右值转换会将一个左值变成一个同类型的右值, 通过读取和这个左值相关的存储区域或者寄存器即可. 这个转换因此也实现了两件事情: 首先, 其保证了左值可以在任何期望右值的场景使用, 其次, 其表示了在程序中的何处编译器应该*发射*一个加载指令, 以从内存读取一个值.



## B.2 C++11后的值类型分类



