## 7.2 传引用?

现在我们再讲讲传引用的不同效果, 在所有情况下, 绝对不会发生拷贝, 而且, 传入的参数永远不会退化. 然而, 有时候传入是不行的, 就算可行的情况下, 也是有导致出现问题的情况的.



### 7.2.1 传入常引用

为了避免任何不必要的拷贝, 当传入非临时对象的时候, 我们可以使用常引用.举个例子:

```cpp
template <typename T>
void printR(T const& arg) {
    // ...
}
```

这样定义的话, 传入一个对象永远不会发生拷贝, (就算不会减少开销):

```cpp
std::string returnString();
std::string s = "hi";
printR(s); // no copy
printR(std::string("hi")); // no copy
printR(returnString()); // no copy
printR(std::move(s)); // no copy
```

就算`int`也是通过引用传入的,  有点事与愿违, 但是也没啥问题, 因此下面的代码:

```cpp
int i = 42;
printR(i); // 传入了引用, 而未进行拷贝
```

将导致`printR`被如下地实例化:

```cpp
void printR(int const& arg) {
	// ...
}
```

在表象之下, 传引用是由传地址来实现的, 地址被简洁的编码, 因此传地址对于调用者和被调用的函数都是足够高效的, 然而, 传地址可能给程序的编译期带来不确定性. 被调用的函数可能会对这个地址干什么, 理论上, 被调用的函数可以修改通过这个地址访问到的所有值. 这意味着, 编译器必须假定所有可能被缓存的值在调用后都可能变得无效. 重新载入这些值开销可能十分大. 你可能在想, 传常引用啊, 难道编译器不能推断出什么都没变吗! 遗憾的是, 确实不能, 因为调用者可能通过自己的非常引用修改之. 还有`const_cast`.

内联可能会让情况不那么糟糕, 如果编译器可以将调用展开为内联, 那么它就可以基于调用者和被调用者的信息, 推断出被传递地址中的值是否会被更改. 函数模板通常总是很短, 因此很可能会被做inline 展开. 但是如果模板中有复杂的算法逻辑, 那么它大概率就不会被做inline 展开了. 



### 传入不退化的引用

当传入引用的时候, 它们都不会退化. 这意味着裸数组将不会被转化为指针, 而且cv限定符也不会被移除. 然而, 调用参数声明为了`T const&`, 模板参数`T`其将不会被推导为`const`.举个例子:

```CPP
template <typename T>
void printR(T const & arg) {
    // ...
}

std::string const c = "hi";
printR(c); // T 被推导为了 std::string, arg 是std::string const&
printR("hi"); // T 被推导为 char[3], arg 是 char const(&)[3]
int arr[4];
printR(arr); // T 推导为 int[4], arg 是 int const(&)[4]
```

因此对于在`printR()`中用`T` 声明的变量, 它们的类型中也不会包含`const`.



### 7.2.2 通过非常引用传参

当我们想通过传入的实参返回值的时候, 我们必须使用非常引用. 