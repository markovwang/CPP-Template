## 4.4 变参类模板和变参表达式

除了上面的例子,  参数包可以出现在别的位置, 举个例子, 包括: 表达式, 类模板, `using`声明, 甚至是推断引导. 12.4.2小节中有完整的支持列表.

### 4.4.1 变参表达式

除了转发参数, 我们可以做的还有更多, 我们可以用它做计算, 具体是在一个参数包中计算所有的参数.

举个例子, 下面的例子可以将参数包中的每个实参翻倍, 然后将翻倍后的数传给`print()`:

```cpp
template<typename... T>
void printDoubled (T const&... args){
    print(args + args...);
}
```

举个例子, 如果你调用它:

```cpp
printDdoubled(7.5, std::string("hello"), std::complex<float>{4,2});
```

函数会发生下面的行为:

```cpp
print(7.5 + 7.5,
		std::string("hello") + std::string("hello"),
		std::complex<float>(4,2) + std::complex<float>(4,2);
```

如果你只是想给每一个实参加1, 记住, 省略号那些点不能直接跟在一个数字字面值后面.

```cpp
template <typename... T>
void addOne (T const& ... args){
    print (args + 1...);			// 1... 这个字面量后面点太多了
    print (args + 1 ...);			// OK
    print ( (args + 1)... );		// OK
}
```

编译期表达式可以包含模板参数包, 举个例子, 下面的函数模板就返回了后面的实参类型是否相同.

```cpp
template <typename T1, typename... TN>
constexpr bool isHomoGeneous (T1, TN...){
    return f(std::is_same_v<T1,TN>&&...);		//C++17起
}
```

这是一个折叠表达式的一个应用. 对于下面的表达式:

```cpp
isHomogeneous (43, -1, "hello");
```

其将展开为:

```cpp
std::is_same_v<int,int> && std::is_same_v<int, char const*>
```

其将返回`false`, 然而:

```cpp
isHomogeneous("hello","world","!");
```

将会返回`true`, 并且所有的实参都被推导为`char const*`.



### 4.4.2 变参索引

另一个例子, 下面的函数使用了变参列表索引来访问相应的元素:

```cpp
template <typename C, typename... Idx>
void printElems (C const& coll, Idx... idx) {
    print(cool[idx]...);
}
```

这意味着,当我们这样调用时:

```cpp
std::vector<std::string> cool {"good", "times", "say", "bye"};
print(coll, 2,0,3);
```

就等同于调用:

```cpp
print (coll[2], coll[0], coll[3]);
```

你也可以声明非类型模板参数作为参数包, 举个例子:

```cpp
template <std::size_t... Idx, typename C>
void printIdx (C const& coll){
    print(coll[Idx]...);
}
```

这允许你这样调用...

```cpp
std::vector<std::string> coll = {"good", "times", "say", "bye"};
printIdx<2,0,3>(coll);
```

其和前面的例子效果相同.



### 4.4.3 变参类模板

