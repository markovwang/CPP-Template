# 第二章

# 	类模板	



和函数类似, 类也可以被一个或者更多类型参数化. 容器类, 用来管理某种特定类型的元素, 就是这个特性的一个典型例子. 通过使用类模板, 你可以在其元素类型未定的情况下实现某个容器类. 本章中, 我们使用栈作为类模板的一个例子.



## 2.1 栈的类模板实现

就像在函数模板里那样, 我们在头文件中声明并定义类`Stack<>`:

```cpp
// basics/stack1.cpp

#include <vector>
#include <cassert>

template<typename T>
calss Stack{
  
private:
    std::vector<T> elems;			// 元素
public:
    void push(T const& elem) ;		// 存入元素
    void pop();						// 弹出元素
    T const& top() const;			// 返回栈顶元素
    bool empty() const{				// 返回栈是否空
        return elems.empty();
    }
};

template<typenam T>
void Stack<T>::push (T const& elem){
    elems.emplace_back(elem);
}

template<typename T>
void Stack<T>::pop (){
    assert(!elems.empty());
    elems.pop_back();
}

template<typename T>
T const& Stack<T>::top() const {
    assert(!elems.empty());
    return elems.back();
}
```

如你所见, 这个栈的类模板通过使用`vector`来实现. 结果就是, 我们不用写内存管理, 拷贝构造, 赋值运算符, 所以我们只用注意到类模板的接口上来.



### 2.1.1 类模板的声明

声明类模板和声明函数模板很相似, 在声明之前, 先声明一个或者多个类型参数. 我们又一次使用了`T`作为类型标识符.

```cpp
template<typename T>
class Stack{
    ...
};
```

当然, 此处的`typename`换成`class`也是可以的.

在类模板的内部, `T`可以像任何其他的类型一样来声明成员函数和成员变量. 在本例中, `T`被用来声明vector的类型, 并且`push`使用了其当作参数类型, `top`试用其作为返回类型.