## 7.4 处理字符串字面值和裸数组



到目前为止, 我们已经经历过使用字符串字面量和裸数组的不同效果了:

- 通过传值, 会使类型退化成元素类型的指针.
- 传引用的情况下不会导致实参退化.

两者都有好处与缺点, 当数组退化为指针的时候, 我们就不能区分传入的指针和数组. 另外, 当处理传入的字符串字面量, 不退化吧, 也有问题, 因为不同长度的字符串字面量的类型不同. 举个例子:

```cpp
template<typename T>
void foo (T const& arg1, T const& arg2)
{
	// ...
}
foo("hi", "guy"); //ERROR
```

在调用时会炸掉, 因为前者的类型是`char const[3]`, 后者的类型是`char const [4]`, 但是模板又要求两者类型相同.只有长度相同才能通过编译. 于是, 我们强烈建议在测试用例中使用长度不同的字符串.

而通过声明函数模板`foo()`以传值便可以了:

```cpp
template<typename T>
void foo (T arg1, T arg2)
{
	//...
}
foo("hi", "guy"); //compiles, but …
```

但是, 这不意味着没问题了... 甚至更拉了, 这下可好, 编译期没问题了, 但是成运行时问题啦! 考虑下面的代码: 我们用`==`运算符来比较传入的实参.

```cpp
template<typename T>
void foo (T arg1, T arg2)
{
	if (arg1 == arg2) { //OOPS: compares addresses of passedarrays
		//...
	}
}
foo("hi", "guy"); //compiles, but …
```

就像写的那样, 你必须将传入的指针解释为字符串, 但是, 情况可能不是这样, 因为模板还要处理已经退化的实参. 