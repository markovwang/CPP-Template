## 7.4 处理字符串字面值和裸数组



到目前为止, 我们已经经历过使用字符串字面量和裸数组的不同效果了:

- 通过传值, 会使类型退化成元素类型的指针.
- 传引用的情况下不会导致实参退化.

两者都有好处与缺点, 当数组退化为指针的时候, 我们就不能区分传入的指针和数组. 另外, 当处理传入的字符串字面量, 不退化吧, 也有问题, 因为不同长度的字符串字面量的类型不同. 举个例子:

```cpp
template<typename T>
void foo (T const& arg1, T const& arg2)
{
	// ...
}
foo("hi", "guy"); //ERROR
```

在调用时会炸掉, 因为前者的类型是`char const[3]`, 后者的类型是`char const [4]`, 但是模板又要求两者类型相同.只有长度相同才能通过编译. 于是, 我们强烈建议在测试用例中使用长度不同的字符串.

而通过声明函数模板`foo()`以传值便可以了:

```cpp
template<typename T>
void foo (T arg1, T arg2)
{
	//...
}
foo("hi", "guy"); //compiles, but …
```

但是, 这不意味着没问题了... 甚至更拉了, 这下可好, 编译期没问题了, 但是成运行时问题啦! 考虑下面的代码: 我们用`==`运算符来比较传入的实参.

```cpp
template<typename T>
void foo (T arg1, T arg2)
{
	if (arg1 == arg2) { //OOPS: compares addresses of passedarrays
		//...
	}
}
foo("hi", "guy"); //compiles, but …
```

就像写的那样, 你必须将传入的指针解释为字符串, 但是, 情况可能不是这样, 因为模板可能还要处理已经退化的实参. (比如它们可能来自于另一个按值传递的函数, 或者是`auto`声明的).

不管怎样,  大多数情况下退化是有用的, 尤其是检查两个对象是否转化成了同一类型. 一个典型的应用就是完美转发. 但是如果你想用完美转发. 你必须显式的使用`std::decay`对实参进行退化. 详见7.6小节的例子.

注意, 一些类型萃取有时也会隐式退化. 比如`std::common_type`, 其返回两个传入实参的共同类型.



### 7.4.1 对于字符串字面量和裸数组的特殊实现

你可能必须根据传指针和传数组以区分实现. 当然, 这要求一个尚未退化的数组啦.

为了区分这些例子, 你必须监测是否传入的是数组. 基本上, 有两种选择. 

- 你可以声明模板参数时期只适用于数组:

  ```cpp
  template <typename T, std::size_t L1, std::size_t L2>
  void foo(T(&arg1)[L1], T(&arg2)[L2]) {
      T* pa = arg1;
      T* pb = arg2;
      if(compareArrays(pa, L1, pb, L2)) {
          // ...
      }
  }
  ```

  此处, `arg1`和`arg2`必须是两个同类型裸数组, 并有着不同的大小`L1`和`L2`, 然而, 你必须多种的实现以支持不同形式的裸数组. 

- 可以使用类型萃取已确定是否传入了数组或者指针

  ```cpp
  template<typename T,
  				typename = std::enable_if_t<std::is_array_v<T>>>
  void foo (T&& arg1, T&& arg2)
  {
  	// ...
  }
  ```

  由于这些特殊的处理方式, 通常来说, 用不同的方式处理不同的数组是用不同的函数名.   或者更好的方法是, 确定调用者使用`vector`或者`array`, 但是只要字符串字面量是裸数组, 我们就要考虑这些问题.

  

  