## 7.3 使用`std::ref`和`std::cref`

从C++11起, 我们可以让调用者决定是传值还是传引用. 当模板本定义的是传值的时候, 可以通过`std::ref()`和`std::cref()`来传引用. 看例子

```cpp
template<typename T>
void printT (T arg) {
	//...
}
std::string s = "hello";
printT(s); //pass s by reference
printT(std::cref(s)); // pass s “as if by reference”
```

然而, 注意`std::cref()`不在模板中改变其持有的参数. 相反, 它用了一个小技巧, 其用一个对象包装了这个参数, 并让它表现的像一个引用. 实际上, 其创建了一个类型为`std::reference_wrapper<>`的对象, 引用了原实参. 这个包装器仅支持一个操作. 一个转化为原类型的隐式类型转换.其返回原对象. 于是, 不管你是否有合法的操作符, 你都可以使用引用包装器. 举个例子:

```cpp
#include <functional> // for std::cref()
#include <string>
#include <iostream>
void printString(std::string const& s)
{
	std::cout << s << ’\n’;
}
template<typename T>
void printT (T arg)
{
    printString(arg); // might convert arg back to
    std::string
}
int main()
{
    std::string s = "hello";
    printT(s); // print s passed by value
    printT(std::cref(s)); // print s passed “as if by reference”
}
```

