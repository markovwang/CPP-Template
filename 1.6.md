##　难道，我们不该．．．

也许, 即便是这些简单的函数模板都会都会给我们带来一堆问题, 此处有三个常见问题, 值得我们讨论.

### 1.6.1 传值还是传引用?

你可能一直在琢磨, 我们为什么声明的时候一般让它通过值传参而非模板呢? 一般来讲, 传引用更推荐被用于除简单类型意外的其它类型(比如基本类型或者`std::string_view`). 因为可以避免不必要的拷贝.

然而, 从某些原因上来讲, 传值比传引用还是要好的.

- 语法更简单.
- 编译器能更好的优化.
- 移动语义的成本更低.
- 有时候也许根本没有拷贝或者移动.

还有, 对于模板来说, 另有一些特殊情况.

- 模板可能被用于简单类型和复杂类型, 所以如果默认选择合适于复杂类型的可能方式, 可能对简单类型产生不利影响.
- 作为调用者, 其实也能决定传参还是传引用(即使用`std::ref`,`std::cref`)(详见第7.3小节)
- 尽管传递字符串字面值和裸数组一般会导致问题, 传引用的话可能问题更严重. 这些都将在第7章讨论. 当前在本书中我们还是传值吧, 除了某些不得不传引用的场景.

### 1.6.2 为什么不用`inline`

一般来说, 函数模板不必要被声明为`inline`, 不像普通非内联函数那样, 我们可以把非内联函数模板定义在头文件中, 然后在多个编译单元中包含此文件.

唯一一个例外是为特定类型进行全特化, 此时它也算不上泛型了(毕竟所有模板参数都已经被确定了).详见9.2小节.

从严格的预言角度来讲, `inline`只意味着在程序中函数的定义可以出现多次, 不过其也暗示编译器应在调用处展开. 这样做在某些情况下会提升效率, 但也说不准降低效率. 现代编译器会在没有inline的情况下决定时候将函数展开成内联的. 当然, 编译器不会忘记`inline`的存在的.

### 1.6.3 为何不用`constexpr`

从C++11起, 我们可以使用`constexpr`关键字来在编译期进行一些计算. 对于很多模板其都能生效.

举个例子, 为了能够在编译阶段使用求最大值函数, 我们得这么写:

```cpp
template<typename T1, typename T2>
constexpr auto max(T1 a, T2 b)
{
    return b < a ? a : b;
}
```

这样的话, 你就能在编译阶段的上下文中, 实时使用它:

```cpp
int a[::max(sizeof(char),1000u)];
```

或者指定`std::array<>`的大小.

```cpp
std::array<std::string, ::max(sizeof(char),1000u)> arr;
```

此处我们传递的是`unsigned int`类型1000, 可以避免直接比较一个有符号数和无符号数时产生警告.

8.2小节会讨论其他的一些实用`constexpr`的例子, 但是目前为了更专注于其基本原理, 我们会在讨论模板特性时略过不讲.