## 重载函数模板

就像常规函数一样, 函数模板可以被重载, 即, 你可以对同名函数进行不同的定义, 因此在用户调用函数的时候, C++编译器必须决定调用哪一个实现候选. 决定调用哪个版本的过程十分复杂——就算不加上模板, 在本节中, 我们介绍当模板介入其中时的重载.如果你对没有模板的函数基本重载规则不熟悉的话, 建议看看附录C, 其中提供了颇为详细的重载决议规则.

下面的小例子阐述了函数模板的重载:

```cpp
// basics/max2.hpp

// 两个整形中的较大值
int max( int a, int b)
{
    return b < a ? a : b;
}

// 任意类型的两个值的较大值
template<typename T>
T max (T a, T b)
{
    return b < a ? a : b;
}

int main()
{
    ::max(7,42);			// 调用无模板版本
    ::max(7.0, 42.0);		// 调用了max<double>(使用了模板实参推断)
    ::max('a','b');			// 调用了max<char>(使用奴办事惨推断)
    ::max('a',42.7);		// 调用了无模板版本
}
```

如本例所示, 一个非模板版本的函数可以和其模板版本同时存在. 在其他因素完全相同的情况下, 重载解析过程将更愿意调用非模板版本. 刚刚第一个调用遵守下面的规则:

```cpp
::max(7,42);	// 双int完美匹配非模板版本
```

如果模板能够生成一个更加匹配的函数, 此时就用了模板的版本了, 第二次和第三次调用就演示了这种情况:

```cpp
 ::max(7.0, 42.0);		// 调用了max<double>(使用了模板实参推断)
 ::max('a','b');		// 调用了max<char>(使用奴办事惨推断)
```

此处, 模板更加合适, 因为不需要从`double`或者`char`转为`int`类型.

我们也可以通过显式的指定一个空的模板实参列表. 这种语法表明只有模板才能解析这个调用, 但是所有的模板参数都应该从调用实参推断:

```cpp
::max<>(7,42);			// 调用max<int>(通过实参推断)
```

因为自动类型转换并不在推断模板参数时被考虑进来, 但是在调用普通函数是 其参数可能会进行自动类型转换, 看最后一个例子('a'和42.7被转化为了`int`类型):

```cpp
::max('a',42.7);		// 只有非模板函数允许非平凡转换
```

