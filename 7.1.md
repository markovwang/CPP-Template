# 第七章 传值还是传引用?



从那时起, C++就提供了传值还有传引用两种传参方式. 然而决定用哪种方式一直是个老大难问题. 一般而言, 传引用的话对于非平凡类开销更低, 但是会稍显复杂. C++11又把移动语义参乎到里面了, 意味着我们又有新的传引用的方式了.

1. `X const&` (常左值引用): 形参是传入对象的引用, 但无法修改.
2. `X&` (非常左值引用): 形参是传入对象的引用, 但可以修改.
3. `X&&` (右值引用): 使用移动语义, 将传入对象引用到形参上, 也就是说我们可以修改*偷*来的这个值.

对于已知确定类型确定如何声明参数已经够复杂了, 在模板中, 类型是未知的, 决定那个传参方式就更复杂了. 

但是在1.6.1小节中, 我们确实推荐向函数模板中通过值传参, 不过有一些例外情况:

- 对象不可拷贝
- 参数被用于返回数据
- 参数以及其所有属性需要被模板转发到别的地方
- 性能提升, 大大滴干活

本章将讨论模板中传递参数的几种方式, 并将证明为何应该优先使用按值传递, 也列举了不该使用按值传递的情况. 同时讨论了在处理字符串常量和裸指针时遇到的问题. 

建议看看附录B, 了解一下左值, 右值, 纯右值, 亡值(看看本贾尼老爷子的书上也解释了:

[cppreference](https://zh.cppreference.com/w/cpp/language/value_category)



## 7.1 传值?

当通过值传参的时候, 原则上每个实参都会被拷贝. 因此, 每个参数都成为传入实参的一份拷贝. 对于类来说, 对象的拷贝是由拷贝构造函数初始化的.

调用拷贝构造函数的开销很大啊, 然而, 我们有很多办法能防止通过值传参的时候进行昂贵的拷贝:

实际上, 编译器可以优化掉拷贝动作, 并且可以通过移动语义使得复杂对象的初始化不那么昂贵. 

举个例子, 我们实现一个传值的函数模板:

```cpp
template <typename T>
void printV(T arg) {
    // ...
}
```

就比如在使用整形调用此模板, 代码就会变成这样:

``` cpp
void printV (int arg) {
    // ...
}
```

参数`arg`成为了传入实参的一份拷贝, 不管其是一个对象,还是字面量, 还是一个函数返回的值. 

如果我们定义了一个字符串, 然后为其调用我们的函数模板.

```cpp
std::string s = "hi";
printV(s);
```

于是模板参数`T`被实例化为了`std::string`, 于是我们得到了

```cpp
void printV(std::string  arg) {
    // ... 
}
```

再强调一次, 让我们传入字符串的时候, `arg`变成了`s`的一份拷贝, 这一次这份拷贝是由拷贝构造函数产生的, 可能导致昂贵的开销, 因为原则上, 原则上这个拷贝操作将产生一次全拷贝或者叫深拷贝, 所以这份拷贝将会分配自己的内存以存储值. 

然而, 这个潜在的拷贝构造函数并非总是被调用, 看看下面的代码:

```cpp
std::string returnString();
std::string s = "hi";
printV(s);						// 调用拷贝构造函数
printV(std::string("hi"));		// 拷贝一般被优化掉了, 如果没有的话, 好歹也是移动构造
printV(returnString());			// 同上
printV(std::move(s));			// 移动构造
```

第一个调用我们传入了左值, 其意味着, 拷贝构造函数将被使用, 然而, 第二个和第三个调用, 当我们为纯右值直接调用函数模板时, 编译器通常会优化传入的实参以达到不调用拷贝构造函数的目的, 注意一点, C++17中这个优化是必须的, 在C++17之前, 不优化拷贝的编译器必须至少尝试用用移动语义, 其一般能让拷贝的开销少一点. 在上一次调用的时候, 当传入将亡值的时候, 我们发出不再需要`s`的值的时候, 将强制调用移动构造函数. 

因此, 只有当我们向`printV`传入左值的以声明参数的时候才会变得昂贵. 不幸的是, 这是一个十分常见的例子, 一个原因是先创建对象再传入到其他函数是一个十分常见的事情.



### 传入值的退化

我们之前还提过一种传入值的属性, 那就是以值的形式传入的时候, 类型会退化. 这意味着裸数组将转化为指针, cv限定符也将被除去:

```cpp
std::string const c = "hi";
printV(c); // 退化为 std::string
printV("hi"); //退化为 char const*
int arr[4];
printV(arr); // 退化为 int const*
```

因此, 当传入字面量"hi"的时候, 其类型退化为了`char const *`, 于是模板将实例化为这样:

```cpp
void printV (char const * arg) {
    // ...
}
```

这种行为是从C语言继承而来, 其既有好处也有缺点, 其经常简化处理字符串字面量, 但是, 缺点在于, 我们无法在函数内部区分是单个元素的指针还是裸数组. 因此, 我们将在7.4小节讲讲具体如何处理.





