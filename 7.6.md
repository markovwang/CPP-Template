## 7.6 推荐的模板参数声明

向我们前几节学过的那样, 我们可以有很多不同的方法来根据模板参数声明参数.

- 声明通过值来传参:

  - 这个方法很简单, 将退化字符串字面量和裸数组, 但是对于大对象无法提供最好的性能, 调用者仍然可以通过使用`std::cref`或者`std::ref`来通过引用传参, 不过调用者应小心行事以保证操作有效.

- 声明通过引用来传参.

  这个方法对于大对象提供了更好的性能, 尤其是下面的情况:

  - 已存在的对象到左值引用.
  - 临时对象(纯右值)或者摇移动的(将亡的)对象的右值引用.
  - 或者两者的通用引用.

  因为上面的情况都不会退化. 所以在传字符串字面量或者裸数组的时候应该特别小心. 对于通用引用,你依然要小心这个方法中的模板参数也可能隐式的被声明为引用类型.



### 一般的推荐

上述选项牢记心中, 对于函数模板, 我们有以下推荐:

1. 默认的话, 声明模板参数传值, 这个方式更加简单, 而且对于字符串字面量也能够很好的工作. 对于小对象或者临时的, 可移动的对象, 其性能是很好的, 而当调用者想传入大对象时可以使用引用包装以减少昂贵的拷贝开销. 
2. 如果有足够好的原因的话, 就换个做法:
   - 如果你需要传出参数或者传入/传出参数, 其返回一个新的对象或者允许修改传入的参数, 传入一个非常引用(除非宁喜欢用指针). 然而, 你可能像7.2.2小节讨论的那样考虑禁止意外的接受常物体.
   - 如果一个模板是来转发参数的, 请使用完美转发. 这意味着, 声明通用引用并使用`std::forward<>`, 尝试使用`std::decay`和`std::common_type`来调和字符串字面量和裸数组的不同类型.
   - 如果你的软件是性能第一的话, 而且你觉得拷贝的开销很昂贵的话, 请使用常引用, 当然, 如果你需要一份内部拷贝的话,这种情况就不适用了.
3. 如果宁觉得自个儿是个老懂哥的话, 就别听我啦(书也别看啦), 然而, 不要对性能上做直觉上的假设, 就算是专家在尝试的时候都会惨败. 相反, 宁测一测吧.



### 不要过度泛型

注意, 在实践中, 函数模板常不是任意类型的实参, 相反, 是有一些限制的, 举个例子, 你可能知道只有一些类型的`vector`才能传入,  这种情况下, 还是不要把函数定义的过于泛型比较好. 因为, 如讨论那般, 可能出现各种意想不到的副作用, 相反, 用下面的写法:

```cpp
template<typename T>
void printVector (std::vector<T> const& v)
{
	// ...
}
```

