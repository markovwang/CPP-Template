## 1.2 模板实参推断

当我们用实参调用一个类似`max()`的函数模板的时候, 模板形参将取决于我们传入的实参. 如果我们把两个`int`创个`T`, C++的编译器必将认为T是`int`.

然而, `T`有可能只是类型的一部分, 举个例子, 当我们使用常量引用声明`max()`的时候:

```cpp
template<typename T>
T max (T const& a, T const& b)
{
	return b < a ? a : b;
}
```

这时候向其中穿入一个`int`, 此时`T`将被推导为`int`, 因为函数形参匹配`int const& `的形式.

### 类型推断期间的类型转换

注意到在类型推断期间自动类型转换是十分有限的:

- 当以引用形式声明调用参数时, 多么简单的类型转换也不会应用在类型推导中, 两个由相同的模板实参`T`声明的实参必须精确的相同.
- 当以值的形式声明调用参数时, 只会发生类型退化这种简单转换: `const`和`volatile`限定符会被忽略, 引用会被转化为引用类型, 原生数组和函数将被转化为相应的指针类型, 对于被相同模板形参`T`声明的两个实参退化后的类型必须匹配.

举个例子:

```cpp
template<typename T>
T max(T a, T b);
// ...
int const c = 42;
max(i, c);				// T将被推导为int类型;
max(c, c);				// T将被推导为int类型;
int& ir = i;
max(i, ir);				// T将被推导为int类型;
int arr[4];
foo(&i, arr);			// T将被推导为int*类型;
```

然而下面这些会导致错误:

```cpp
max(4, 7.2);			// 错误, T既可以被推导为int, 也可以被推导为double
std::string s;
foo("hello", s);		// 错误, T既可以被推导为 char const[6], 也可以被推导为std::string
```

当然, 我们倒是有解决这些问题的方法:

1. 对实参进行类型转化, 时期都能匹配:

```cpp
max(static_cast<double>(4), 7.2);		// 可行
```

2. 指定T的类型, 阻止编译器尝试进行类型推导:

```cpp
max<double>(4, 7.2);		// 可行
```

3. 指定可能有不同类型的参数

1.3节汇兑这种情况进行详细说明, 7.2节和15章将详细讨论类型推导中的类型转换.



### 默认实参类型推导

注意到, 在默认调用实参的时候, 类型推导不会起作用, 举个例子:

```cpp
template<typename T>
void f(T = "");

f(1);					// 可行, 将T推导为int, 即调用f<int>(1);
f();					// 不行, 无法推导T的类型;
```

为了支撑这个例子, 你需要为此模版形参生命一个默认实参, 其将在1.4小姐讨论.

```
template<typename T = std::string>
void f(T = "");
// ...
f();					// 可行
```

