## 6.4 使用`enable_if<>`

6.2节那个问题... 你应该还没忘, 我们解决以下那个问题吧.

我们要解决的问题是如果传入的`STR`是指定类型的话, 就就用掉这个模板构造函数的声明:

```cpp
template <typename STR>
Person (STR&& n);
```

再介绍一个类型萃取, `std::is_convertible<FROM, TO>`, 在C++17标准中, 相应的声明是这样的:

```cpp
template <typename STR,
			typename = std::enable_if_t<
                		std::is_convertible_v<STR, std::string>>>
Person(STR&& n);
```

如果`STR`能转换为`std::string`类型的话, 此声明将展开成这样:

```cpp
template <typename STR,
		  typename = void>
Person(STR&& n);
```

如果不能转换的话... 这个函数模板就被禁用了.

协程别名模板是更吼的~:

```cpp
template<typename T>
using EnableIfString = std::enable_if_t<
						std::is_convertible_v<T, std::string>>;
template<typename STR, typename = EnableIfString<STR>>
Person(STR&& n);
```

这样它就可以正确的调用拷贝构造函数了~