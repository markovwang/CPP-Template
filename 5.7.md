## 5.7 模板模板参数

让模板参数本身是一个类模板是一个很有用的特性. 又一次, 我们的stack类, 又可以当作一个例子.

为了让stack能使用不同的内部类, 程序员必须制定两次元素类型. 因此, 为了指定内部容器的类型, 你必须传入容器的类型, 并再一次指定元素类型:

```cpp
Stack<int, std::vector<int>> vStack;		// 使用vector实现int的stack
```

使用模板模板参数, 可以让你仅仅指定容器类性而不用再次指定元素类型:

```cpp
Stack<int, std::vector> vStack;				// 妙啊!
```

为了实现这种写法, 你必须把第二个模板参数定义为模板模板参数, 原则上它该长这样:

```cpp
template <typename T, template<typename Elem> class Cont = std::queue>
class Stack {
private:
    Cont<T> elems;		// 元素
public:
    void push(T const&);
    void pop();
    T const& top() const;
    bool empty() const {
        return elems.empty();
    }
};
```

不同之处在于第二个模板参数被声明为了类模板:

```cpp
template<typename Elem> class Cont
```

默认值从`std::deque<T>`变成了`std::deque`, 这个参数必须是一个类模板, 其被实例化为传入的第一个模板参数的类型:

```cpp
Cont<T> elems;
```

用第一个模板参数实例化第二个模板参数的情况算是本例的一个特殊情况. 实际上, 可以在类模板内部用任意类型实例化一个模板参数模板.

和往常一样, 声明模板时可以用`class`代替`typename`关键字, 在C++11之前,`Cont`只能被类模板的名字替换:

```cpp
template <typename T,
	template<class Elem> class Cont = std::deque>
class Stack  {
    
};
```

自C++11起, 我们就可以通过模板别名来替代之, 但是直到C++17才能用`typename`而不一定用`class`来声明模板模板参数:

```cpp
template <typename T,
			template<typename Elem> typename Cont = std::deque>	//直到C++17才能这样写
class Stack {
    
};
```

这两种变体都是一种东西: 使用`class`而非`typename`关键字并不会妨碍我们将一个别名模板作为`Cont`的实参.

因为这个模板模板参数的模板参数并没有被使用, 把这个名字扔了也无所谓(除非它能提供有用的文档):

```cpp
template<typename T, 
		template<typename > class Cont = std::deque>
class Stack{
    
};
```

注意, 虽然模板参数模板是类或者别名类的占位符, 但是并没有与其对应的函数模板或者变量模板的占位符.