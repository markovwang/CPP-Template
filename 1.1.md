# 第一章: 函数模板

本章介绍函数模板, 函数模板是一种参数化的函数们, 他们能够提供一个函数族.



## 1.1 初遇函数模板

函数模板提供一种对不同的类型可以被调用的函数行为. 换言之, 函数模板提供一个函数族, 这种表示方法看起来像普通的函数——除了它的一些元素未被定义, 这些元素被参数化了. 为了能够给你展示, 我们来看一个简单的例子.



### 1.1.1 定义模板

下面是个能够返回两个值的中较大值的一个函数模板:

```cpp
// 定义在头文件 basics/max1.hpp中

T max (T a,T b)
{
	// 若 b < a 则返回a, 否则返回 b
	return b < a ? a : b;
}
```

这个模板定义了一个函数族, 能够返回两只中的较大值, 这两个值由函数参数`a`和`b`传入[^1]. 这些参数的类型保留为*模板参数`T`*, 如同刚刚看到的这个例子, 模板参数需要以以下的方式进行声明:

```cpp
template< 逗号分隔的参数列表 >
```

在本例中, 参数列表是`typename T`. 注意`<`和`>`符号被用作了括号, 我们称其为*尖括号*,  `typename`关键字引入了一个类型参数, 这是C++程序中大多模板参数的样子, 但是其他样子的参数也有, 对此我们在第三章见.

此处, 类型参数是`T`, 你可以把任何标识符用作参数的名字, 但是用`T`比较方便. 这个类型参数表示它可以是任意类型, 直到调用者调用此函数才会决定其类型. 你能使用任何类型(基本类型, 类, 或者其他什么)——只要它能提供模板使用的操作. 在本例中, 类型`T`必须支持`<操作符`因为`a`和`b`将使用此操作符进行比较, 可能`max()`的定义中不太容易看出的是类型T必须是可复制的, 以便能够返回.[^2]

因为一些历史因素, 你也能用`class`关键字代替`typename`关键字定义类型参数, `typename`关键字在C++98被提出来. 在那之前, `class`关键字是唯一被用来引入类型参数的, 直到今天其依然是合法的.在语义上两者也是没有区别的. 然而, 这样写可能导致一些字面上误会, 所以还是用`typename`比较好. 然而, 虽然`class`是可以用的, 但`struct`是不可以用在类型参数的声明的.



### 1.1.2 使用模板

下面的程序展示了如何使用`max()`函数模板:

```cpp
// basics/max1.cpp
#include "max1.hpp"
#include <iostream>
#include <string>
int main()
{
	int i = 42;
	std::cout << "max(7,i): " << ::max(7,i) << ’\n’;
	double f1 = 3.4; double f2 = -6.7;
	std::cout << "max(f1,f2): " << ::max(f1,f2) << ’\n’;
	std::string s1 = "mathematics"; std::string s2 = "math";
	std::cout << "max(s1,s2): " << ::max(s1,s2) << ’\n’;
}
```

在本程序中, `max`被调用了三次, 第一次是两个`int`, 第二次是两个`double`, 第三次是`std::string`, 每次均计算了较大值. 程序的输出结果如下所示:

```
max(7,i): 42
max(f1,f2): 3.4
max(s1,s2): mathematics
```

注意到每次调用的时候均写了`::`, 这是为了确保其能够在全局命名空间中找到. 毕竟我们的标准库还有一个`std::max()`, 在某些情况下调用会导致二义性[^3].

模板并非被编译为一个能够处理任何类型的函数实体, 相反, 针对不同类型的调用, 模板会被编译成不同的函数实体.[^4] 因此, `max()`针对这三个类型均被编译了一次, 比如, 刚刚, 我们第一次调用`max()`的时候, 函数模板中的`T`被替换成了`int`, 也就是这样了:

```cpp
int max (int a, int b)
{
	return b < a ? a : b;
}
```

这个替换模板参数为具体类型的过程被称为*模板实例化*, 它能得到模板的一个实例[^5].

注意, 仅仅是使用模板就会触发模板实例化的过程, 所以不用程序员去单独手动请求实例化. 

类似的, 使用其它类型调用`max()`模板是都会被各自实例化的.

注意一点: `void`类型是一个合法的模板类型实参, 举个例子:

```cpp
template<typename T>
T foo(T*)
{ }
void* vp = nullptr;
foo(vp); // OK: 推断为void
foo(void*)
```



### 1.1.3 模板两轮翻译(原文为'*Two-Phase Translation*')

*这个国内似乎没有固定的翻译, 有的说替换 ,有的说翻译, 差别不大*

尝试把模板实例化一个不支持其中用到的所有操作的实例会导致编译期报错, 举个例子:

```cpp
std::complex<float> c1, c2; // 并没有提供 <操作符
…
::max(c1,c2); // 编译期报错终止
```

因此, 模板是经过两轮"编译''的:

1. 在定义的时候没有实例化, 模板代码会忽略掉和模板参数相关的代码并进行检查, 其包括:
   - 检查发现语法, 比如丢了分号.
   - 出现了未知的名字: 类型名, 函数名——与模板参数无关的.
   - 于模板参数无关的静态断言将被检查.
2. 在实例化期间, 模板会再被检查一次, 以保障代码是合法的, 换言之, 所有依赖模板参数的代码会被二次检查,举个例子:

```cpp
template<typename T>
void foo(T t)
{
	undeclared(); // 如果unceclared()未被定义, 将在第一轮报编译期报错
	undeclared(t); // 如果unceclared(T)未被定义, 将在第二轮报编译期报错
	static_assert(sizeof(int) > 10, //如果 sizeof(int)<=10 总是会报错
								"int too small");
	static_assert(sizeof(T) > 10, //如果T的大小小于10则在第二轮报错.
								"T too small");
}
```

名字将被检查两次这件事被称为`两轮检查`, 将在14.3.1小结讨论.

不过注意到一些编译器不能在第一轮实例化时进行应完成的全部检查[^6], 所以你只能在实例化时才发现应在第一步就被检查出的问题.



### 编译与链接

两轮检查将会导致在使用中出现很严重的问题: 当一个函数模板以一种触发其实例化的方式使用的时候, 编译器会(在某些情况下)查看模板的定义, 其将打破对于常规函数编译和链接的区别, 处理此问题的方法将在第九章介绍, 目前, 我们只讲最简单的方法, 在头文件中定义每一个模板.



[^1]: 注意到`max()`返回的是"`b < a ? a : b`", 而非"`a < b ? b: a`", 以保证函数能够处理两个值等价却不相等的问题, [https://zh.cppreference.com/w/cpp/language/operator_comparison](https://zh.cppreference.com/w/cpp/language/operator_comparison)
[^2]: 在C++17之前, 类型`T`要求可拷贝以传入实参, 但从C++17起, 你可以传入一个临时值(右值),尽管其不能提供一拷贝或者移动构造函数.
[^3]: 比如, 如果如果一个实参类型在`std`空间中定义了, 根据C++的查找规则, 全局和`std`命名空间中的同名函数均会被找到.
[^4]: 一个实体, 谁都能调, 这种是可以做到的, 但不会在实际编程中用到.(它在运行时的效率会低很多)所有的语言规则均是基于不同实参,不同实体的原则.
[^5]:`实例`和`实例化`这两个术语对于面向对象语言,在上下文不同时有不同含义: 从名字上来看, 是一个类的实体的含义. 然而. 这本书是讲模板的, 这个词主要针对模板, 除非我们做了特殊说明.
[^6]: 举个例子, MSVC编译器的某些版本允许不依赖模板参数的未定义名称, 甚至还允许一些语法错误,比如少了个分号.(又黑我大微软, 请加大力度)

