## 5.5 成员模板

类成员也可以是模板, 这对内部类和成员函数都是可行的. 这个能力的应用于优势在将在`Stack<>`模板中再次被展现. 一般情况下, 你只能在栈的类型相同(也就意味着内部元素类型相同)的时候才能将不同的栈相互赋值. 然而, 你可以给stack赋其它类型的元素, 尽管对定义的类型会发生隐式类型转换.

```cpp
Stack<int> intStack1, intStack2;
Stack<float> floatStack;
// ...
intStack1 = intStack2;		// OK
floatStack = intStack1;		// 炸了
```

默认的赋值运算符要求运算符两边类型相同, 显然和上面两边类型不同的例子不一样.

如果把赋值运算符定义为模板的话, 就可以将两个元素类型可以做转换的stack 相互赋值, 新的`Stack<>`长这样:

```cpp
template<typename T>
class Stack {
private:
	std::deque<T> elems; 
public:
	void push(T const&); 
	void pop(); 
	T const& top() const; 
	bool empty() const { 
		return elems.empty();
	}
// 用T2类型赋值
template<typename T2>
Stack& operator= (Stack<T2> const&);
};
```

上面的东西做了一点微小的工作:

1. 添加了一个用类型T2进行赋值运算的声明
2. 改用`std:deque<>`作为内部容器辣

这个声明的实现大概这样:

```cpp
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
	Stack<T2> tmp(op2); // 复制一份
	elems.clear(); // 清除现有
	while (!tmp.empty()) { // 拷贝...
		elems.push_front(tmp.top());
		tmp.pop();
	}
	return *this;
}
```

我们先看一眼这个用来定义成员模板的语法. 在模板内由模板参数`T`, 内部的模板定义了一个模板参数`T2`.

```cpp
template <typename T>
  template <typename T2>
// ...
```

在成员函数内, 你可期望仅仅是简单的访问`op2`的所有必需数据. 然而, 这个stack有着不同的类型(你用两种类型实例化类模板, 你就会有两个不同的类类型), 所以你在使用公开接口时就会有限制. 结果就是访问元素的唯一方法就是调用`top()`. 然而, 每个元素必须是顶上的元素. 于是, 就必须造一份`op2`的备份, 于是调用`pop()`把元素取走. 因为`top()`返回的是推入stack的最后一个元素, 我们可能更倾向于使用可以在其他端掺入的容器, 于是我们使用了`std::deque<>`, 其提供了`push_front()`函数以将元素推入另一端.

为了能够访问到`op2`的所有成员, 你可以把其他的stack实例声明为友元.

```cpp
template<typename T>
class Stack {
private:
	std::deque<T> elems; 
public:
	void push(T const&); 
	void pop(); 
	T const& top() const;
	bool empty() const { 
		return elems.empty();
	}
    
    // 给T2类型的stack赋值
    template<typename T2>
    Stack& operator= (Stack<T2> const&);
    
    // 能访问到private成员
    template<typename> friend class Stack;
};
```

如你所见, 由于模板参数的名字没有用到, 你可以省略它.

```cpp
template<typename> friend class Stack;
```

好, 现在下面的实现就可行了:

```cpp
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
    elems.clear(); // 移除现有
    elements
    elems.insert(elems.begin(), op2.elems.begin(), op2.elems.end());
    return *this;
}
```

