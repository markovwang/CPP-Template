## 5.5 成员模板

类成员也可以是模板, 这对内部类和成员函数都是可行的. 这个能力的应用于优势在将在`Stack<>`模板中再次被展现. 一般情况下, 你只能在栈的类型相同(也就意味着内部元素类型相同)的时候才能将不同的栈相互赋值. 然而, 你可以给stack赋其它类型的元素, 尽管对定义的类型会发生隐式类型转换.

```cpp
Stack<int> intStack1, intStack2;
Stack<float> floatStack;
// ...
intStack1 = intStack2;		// OK
floatStack = intStack1;		// 炸了
```

默认的赋值运算符要求运算符两边类型相同, 显然和上面两边类型不同的例子不一样.

如果把赋值运算符定义为模板的话, 就可以将两个元素类型可以做转换的stack 相互赋值, 新的`Stack<>`长这样:

```cpp
template<typename T>
class Stack {
private:
	std::deque<T> elems; 
public:
	void push(T const&); 
	void pop(); 
	T const& top() const; 
	bool empty() const { 
		return elems.empty();
	}
// 用T2类型赋值
template<typename T2>
Stack& operator= (Stack<T2> const&);
};
```

上面的东西做了一点微小的工作:

1. 添加了一个用类型T2进行赋值运算的声明
2. 改用`std:deque<>`作为内部容器辣

这个声明的实现大概这样:

```cpp
template<typename T>
template<typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
	Stack<T2> tmp(op2); // 复制一份
	elems.clear(); // 清除现有
	while (!tmp.empty()) { // 拷贝...
		elems.push_front(tmp.top());
		tmp.pop();
	}
	return *this;
}
```

