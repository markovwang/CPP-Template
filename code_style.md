

# 本书代码风格说明

C++程序猿们的代码风格各异, 我们也是, 其实也是各种老生常谈的问题, 比如空格放哪里, 分隔符放哪里, 等等. 我们尝试在大体上保持一致, 但也会在某些话题中做一些小的改变. 比如在教程结, 我们可能会大量的使用空格和具体名称来是代码看起来更好, 在后面进阶一些的教程中, 将会采用更加紧凑的命名方式, 也该呢更加合理.

我们请您关注一下类型, 参数, 变量的定义形式, 显然, 各种写法都有可能:

```cpp
void foo (const int &x);
void foo (const int& x);
void foo (int const &x);
void foo (int const& x);
```

尽管这样写有些非主流, 我们还是决定按照`int const`而非`const int`的形式来表示常量整形.我们采用这种写法原因有二, 一是这样写能给"这个常量是什么类型"这个问题一个更简单的答案.总是`const`关键字之前的那个东西. 说实话, 尽管

```cpp
const int N = 100;
```

和

```cpp
int cosnt N = 100;
```

是一个意思.但对于代码

```cpp
int* const bookmark;	// 指针不能变, 但是被指向的值可以改变.
```

此时如果你把`const`限定符放到指针操作符`*`的前面... 天哪, 那你干了一件很蠢的事. 在这个例子中, 指针本身是常量, 而非被指向的那个值.

第二个原因就和写模板时常出现的语法替换原则相关, 看看下面两个使用`typedef`关键字定义类型的例子:

```cpp
typedef char* CHARS;
typedef CHARS const CPTR;	// 指向chars的常量指针
```

 或者使用`using`关键字:

```cpp
using CHARS = char*;
using CPTR = CHARS const;	// 指向chars的常量指针
```

第二个声明的含义在我们将`CHARS`进行文本替换的时候将被保留.

但是呢, 如果我们在限定类型之前写`const`, 这个原则就不会执行.考虑下刚才写的两种类型定义的另一种写法:

```cpp
typedef char* CHARS;
typedef const CHARS CPTR;	// 指向chars的常量指针
```

文本替换`CHARS`将导致不同的含义:

```cpp
typedef const char* CPTR;	// 指向常量chars的指针
```

当使用`volatile`的时候也会出现类似的问题.



再来看空格, 我们决议将空格加在`&`和参数名称之间:

```cpp
void foo (int cosnt& x);
```

这样写的话, 我们强调类型和类型名称之间的分隔. 诚然, 这回使得一些声明颇为迷惑:

```cpp
char* a,b;
```

按照用C语言一脉相承的写法, `a`是指针,`b`是个普通变量, 为了避免这样的迷惑, 我们不要去在一行定义多个变量即可.

这本书主要是讲语言特性, 不过很多技巧, 特性, 辅助模板都出现在C++标准库中, 为了使这两者能够联系起来, 我们因此会展示这些技巧--通过对某些库组件的实现进行举例, 并且使用标准库中的一些实用组件来代价我们自己的复杂例子.因此, 我们也不仅仅使用类似`iostream`和`string`之类基础的头文件, 还会使用类似`cstddef`, `utilities`, `functional`和`type_traits`的东西.

另外, 我们还提供了语言参考, 在附录D中, 包含了C++标准库中关于模板辅助函数的大部分内容. 包括各种类型萃取的详细描述.他们主要被用于复杂的模板编程.