## 1.3 多模板参数

就目前为止, 我们见过的函数模板有两种参数:

1. 模板参数,  在函数名前使用尖括号初始化.

```cpp
template<typename T>		// T是模板参数
```

2. 调用参数, 在函数模板的小括号中声明:

```cpp
T max(T a, T b)				// a和b是调用参数
```

只要你想, 拥有多少模板参数都可以, 举个例子, 你可以为`max()`的调用参数定义两种不同的类型:

```cpp
template<typename T1, typename T2>
T1 max (T1 a, T2 b)
{
	return b < a ? a : b;
}
auto m - ::max(4,7.2);		// 可以运行, 但是返回类型被定义为了第一个实参的类型.
```

 看起来向`max()`模板中传不同类型的参数是可行的, 但是, 如同此例中所展示的那样, 这玩意儿有个问题, 如果你把这些类型中的一种类型作为返回类型, 其它实参的类型也将有可能被转换为此类型, 不管这是否符合调用者原本的意图, 因此, (这种写法的)返回类型取决于调用者的调用顺序. 这样的话, 42和66.66的较大值是`int`的66, 66.66和42的较大值将是`double`的66.66.

C++提供了多种方法来解决此问题:

- 引入一个第三个类型作为返回类型.
- 让编译器找到返回类型.
- 将返回值定义为两者的共同类型.

我们接下来将讨论一下.



### 1.3.1 为返回类型定义模板参数

我们之前讨论过, 模板实参推断允许我们和调用普通函数的语法一样去调用函数模板: 我们不必显式的根据模板参数定义其类型.

然而, 我们也提到过, 我们可以显式的指定模板的类型:

```cpp
template<typename T>
T max (T a, T b);
// ...
::max<double>(4,7.2);		// 以double实例化T
```

当模板和调用参数没有联系或者模板参数不能被确定的情况下, 你必须在调用的时候显式的指定模板实参.举个例子, 你可以引入第三个模板实参来决定函数模板的返回类型:

``````cpp
template <typename T1, typename T2, typename RT>
RT max (T1 a, T2 b);
``````

然而, 模板实参推导并不会考虑RT, 而且RT也不会出现在函数调用参数的类型中, 因此RT不能被推倒.

结果就是你必须要显式的指定模板实参列表, 举个例子:

```cpp
template<typename T1, typename T2, typename RT>
RT max (T1 a, T2 b);
// ...
::max<int,double,double>(4, 7.2);			//可行, 但是有点脱裤子放屁.
```

目前为止, 我们即看过了丝毫没有提到模板实参的例子, 也看了把所有模板实参均提及的例子.