## 4.2 折叠表达式

从C++17起, 加入了一个新的特性, 其可以通过对于全部参数包使用二元操作符以计算结果(亦可以有可选的初始值).

举个例子, 下面的函数返回传入的实参之和:

```cpp
template <typename... T>
auto foldSum (T... s){
    return (... + s);	// (( s1 + s2) + s3) ...
}
```

如果参数包为空, 其格式便有错误(其异常为, 对于`&&`操作符值为真,  对于`||`操作符值为假, 对于逗号表达式一个空的参数包为`void()`).

表4.1中列出了可能的折叠表达式:

| **折叠表达式**           | **值**                                      |
| ------------------------ | ------------------------------------------- |
| `(...op pack)`           | `(((pack1 op pack2) op pack3)... op packN)` |
| `(pack op...)`           | `(pack1 op (...(packN-1 op packN)))`        |
| `(init op ... op pack)`  | `(((init op pack1) op pack2 )... op packN)` |
| `(pack op ... op init )` | `(pack1 op (... (packN op init)))`          |

你可以给折叠表达式用上几乎所有类型的二元操作符(详见12.4.6小节). 举个例子, 你可以使用折叠表达式通过`->*`运算符来遍历一个二叉树.

```cpp
// basics/foldtraverse.cpp

// 定义二叉树的结果和便利辅助函数.
struct Node {
	int value;
    Node* left;
    Node* right;
    Node(int i = 0) : value(i), left(nullptr), right(nullptr) { }
    // ...
};

auto left = &Node::left;
auto right = &Node::right;

// 通过折叠表达式遍历二叉树
template<typename T, typename... TP>
Node* traverse (T np, TP... paths) {
    return (np ->* ... ->* paths);
}

int main() {
    // 初始化二叉树结构
    Node* root = new Node {0};
    root ->left = new Node{1};
    root ->left -> right = new Node {2};
    // 遍历二叉树
    Node* node = traverse(root, left, right);
}
```

