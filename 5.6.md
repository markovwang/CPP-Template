## 5.6 变量模板

从C++14起, 变量也可以被特定的类型参数化, 我们将其称之为变量模板. 

举个例子, 你可以用下面的代码定义pi, 然而并不定义其类型:

```cpp
template <typename T>
constexpr T pi {3.1415926535897932385};
```

注意一点, 和其它几种模板类似, 这个定义最好不要出现在函数内部或者块作用域内部.

为使用变量模板, 你就得指定其类型. 举个例子, 下面就是俩类型:

```cpp
std::cout<< pi<double> << '\n';
std::cout<< pi<float> << '\n';
```

你也可以像下面这种方式使用变量模板, 以在不同的编译单元中使用:

```cpp
//== 头文件header.hpp
template <typename T> val {};		// 零初始化

//== 编译单元1
#include "header.hpp"
int main() {
    val<long> = 42;
    print();
}

//== 编译单元2
#include "header.hpp"

void print() {
    std::cout<<val<long> << '\n';		// 打印42
}
```

变量模板也可以有默认模板实参:

```cpp
template<typename T = long double>
constexpr T pi = T{3.1415926535897932385};
```

你就可以用其莫人类能够或者其他类型:

```cpp
std::cout<<pi<><<'\n';
std::cout<<pi<float><<'\n';
```

然而, 你别忘了写尖括号啊, 不写尖括号就炸咯:

```cpp
std::cout<< pi <<'\n';		// 错了!
```

当然... 变量模板也可以被参数化作为非类型参数. 其也可以被用做参数化初始化器, 举个例子:

```cpp
#include <iostream>
#include <array>

template <int N>
std::array<int, N> arr {};		// N个元素的array, 零初始化
template <auto N>
    constexpr decltype(N) dval = N;		// dval的类型取决于传入的值.

int main() {
    
}
```

